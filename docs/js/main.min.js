/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("$('.s-info__tab').click(function (event) {\n  event.preventDefault();\n  var tab = $('.s-info__tab.active').attr('href');\n  var activeTab = $('.s-info__tab.active');\n  activeTab.removeClass('active');\n  $(this).addClass('active');\n  $(tab).removeClass('active');\n  $(tab).addClass('hide');\n  var tabContent = $(this).attr('href');\n  $(tabContent).removeClass('hide');\n  $(tabContent).addClass('active');\n});\n$(document).ready(function () {\n  var el = $('.partners-slider');\n  var carousel;\n  var carouselOptions = {\n    margin: 20,\n    nav: true,\n    dots: true,\n    slideBy: 'page',\n    navContainer: '.partners-nav',\n    navText: ['<div class=\"partners-slider__btn partners-slider__btn-prev\"><svg width=\"16\" height=\"16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11 2L5 8l6 6\" stroke=\"#fff\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg></div>', '<div class=\"partners-slider__btn partners-slider__btn-next\"><svg width=\"16\" height=\"16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5 2l6 6-6 6\" stroke=\"#fff\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg></div>'],\n    dotsClass: 'partners-slider__dots',\n    responsive: {\n      0: {\n        items: 3,\n        rows: 3 //custom option not used by Owl Carousel, but used by the algorithm below\n\n      },\n      768: {\n        items: 5,\n        rows: 3 //custom option not used by Owl Carousel, but used by the algorithm below\n\n      },\n      991: {\n        items: 8,\n        rows: 2 //custom option not used by Owl Carousel, but used by the algorithm below\n\n      }\n    }\n  }; //Taken from Owl Carousel so we calculate width the same way\n\n  var viewport = function viewport() {\n    var width;\n\n    if (carouselOptions.responsiveBaseElement && carouselOptions.responsiveBaseElement !== window) {\n      width = $(carouselOptions.responsiveBaseElement).width();\n    } else if (window.innerWidth) {\n      width = window.innerWidth;\n    } else if (document.documentElement && document.documentElement.clientWidth) {\n      width = document.documentElement.clientWidth;\n    } else {\n      console.warn('Can not detect viewport width.');\n    }\n\n    return width;\n  };\n\n  var severalRows = false;\n  var orderedBreakpoints = [];\n\n  for (var breakpoint in carouselOptions.responsive) {\n    if (carouselOptions.responsive[breakpoint].rows > 1) {\n      severalRows = true;\n    }\n\n    orderedBreakpoints.push(parseInt(breakpoint));\n  } //Custom logic is active if carousel is set up to have more than one row for some given window width\n\n\n  if (severalRows) {\n    orderedBreakpoints.sort(function (a, b) {\n      return b - a;\n    });\n    var slides = el.find('[data-slide-index]');\n    var slidesNb = slides.length;\n\n    if (slidesNb > 0) {\n      var rowsNb;\n      var previousRowsNb = undefined;\n      var colsNb;\n      var previousColsNb = undefined; //Calculates number of rows and cols based on current window width\n\n      var updateRowsColsNb = function updateRowsColsNb() {\n        var width = viewport();\n\n        for (var i = 0; i < orderedBreakpoints.length; i++) {\n          var _breakpoint = orderedBreakpoints[i];\n\n          if (width >= _breakpoint || i == orderedBreakpoints.length - 1) {\n            var breakpointSettings = carouselOptions.responsive['' + _breakpoint];\n            rowsNb = breakpointSettings.rows;\n            colsNb = breakpointSettings.items;\n            break;\n          }\n        }\n      };\n\n      var updateCarousel = function updateCarousel() {\n        updateRowsColsNb(); //Carousel is recalculated if and only if a change in number of columns/rows is requested\n\n        if (rowsNb != previousRowsNb || colsNb != previousColsNb) {\n          var reInit = false;\n\n          if (carousel) {\n            //Destroy existing carousel if any, and set html markup back to its initial state\n            carousel.trigger('destroy.owl.carousel');\n            carousel = undefined;\n            slides = el.find('[data-slide-index]').detach().appendTo(el);\n            el.find('.fake-col-wrapper').remove();\n            reInit = true;\n          } //This is the only real 'smart' part of the algorithm\n          //First calculate the number of needed columns for the whole carousel\n\n\n          var perPage = rowsNb * colsNb;\n          var pageIndex = Math.floor(slidesNb / perPage);\n          var fakeColsNb = pageIndex * colsNb + (slidesNb >= pageIndex * perPage + colsNb ? colsNb : slidesNb % colsNb); //Then populate with needed html markup\n\n          var count = 0;\n\n          for (var i = 0; i < fakeColsNb; i++) {\n            //For each column, create a new wrapper div\n            var fakeCol = $('<div class=\"fake-col-wrapper\"></div>').appendTo(el);\n\n            for (var j = 0; j < rowsNb; j++) {\n              //For each row in said column, calculate which slide should be present\n              var index = Math.floor(count / perPage) * perPage + i % colsNb + j * colsNb;\n\n              if (index < slidesNb) {\n                //If said slide exists, move it under wrapper div\n                slides.filter('[data-slide-index=' + index + ']').detach().appendTo(fakeCol);\n              }\n\n              count++;\n            }\n          } //end of 'smart' part\n\n\n          previousRowsNb = rowsNb;\n          previousColsNb = colsNb;\n\n          if (reInit) {\n            //re-init carousel with new markup\n            carousel = el.owlCarousel(carouselOptions);\n          }\n        }\n      }; //Trigger possible update when window size changes\n\n\n      $(window).on('resize', updateCarousel); //We need to execute the algorithm once before first init in any case\n\n      updateCarousel();\n    }\n  } //init\n\n\n  carousel = el.owlCarousel(carouselOptions);\n});\n\n//# sourceURL=webpack:///./src/js/main.js?");

/***/ })

/******/ });